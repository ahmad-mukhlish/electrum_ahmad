# Electrum Ahmad

Flutter mobile application targeting mobile and web, with platform-specific widgets split for clarity.

## Tech Stack

- Flutter 3.x
- Dart SDK ^3.9.2
- State management: Riverpod
- Primary datasource : Firebase Auth and Firestore

## Why Riverpod?

- Modern, compile-safe state management that pairs cleanly with `go_router`; GetX brings its own router, which conflicts with that approach.
- Less boilerplate and ceremony than Bloc while staying testable and explicit.
- Keeps dependency injection light and composable as features grow.

## Why Firebase Auth and Firestore?

This is a frontend/mobile take-home, so I chose to go all-in on Firebase Auth + Cloud Firestore.
The focus is on app architecture, UX, and state management rather than building a custom backend. 
All Firebase data access is still funneled through clean architecture and only resides in data layer.
Backend could be swapped later without changing other layers.

## AI-assisted workflow and per-feature docs

- Each feature/task is documented in the `documentations/` folder (separate from code) with:
    - `brief.md` → manual brief containing:
        - Context
        - Scope
        - Requirements
        - Clues
        - Keep in mind
    - `plan.md` → AI-assisted implementation plan
      (generated with Claude / other tools and then curated).

- Reasons for this structure:
    - **Context management**
      Each feature carries its own compact context, removing the need
      to reload the entire codebase into an AI tool or human memory.
    - **Token and time efficiency**
      When resuming work on a feature, only these two files need to be
      reviewed instead of all source files.
    - **Documentation for humans and AI**
      The brief captures intent and constraints; the plan captures the
      approach. Both help reviewers and AI tools stay aligned with the
      intended design.
    - **Separation of concerns**
      Documentation lives in `documentations/` while production code
      stays clean in `lib/`. This makes AI involvement explicit and
      reviewable without cluttering the codebase.


## Project Structure (following clean architecture with MVVM pattern)

```
lib/
  core/
    routing/                    # GoRouter configuration
    services/                   # Firebase Auth, Firestore, Local DB
    utils/                      # Helpers, Design tokens
    widgets/                    # Shared widgets
  features/
    auth/
      data/
        dtos/                   # JSON annotated dtos from datasources
        repositories/           # Implementation of domain repositories
        datasources/            # Data providers (Wrapper to API services / Local services)
      domain/
        entities/               # Business Entity (Model)
        repositories/           # Repository interfaces (contracts)
      presentation/
        viewmodel/
          notifiers/            # Notifiers (View model)
          states/               # Freezed UI states (if any)
        screens/                # Screen (View)
        widgets/
          mobile/               # Widgets tailored for mobile
          web/                  # Widgets tailored for web
          shared/               # Widgets shared between mobile and web
  main.dart                     # App entry point

documentations/                 # AI-assisted docs (separate from code)
  core/
    routing/
      brief.md                  # Context, Scope, Requirement, Clues, Keep in Mind
      plan.md                   # Generated by AI and reviewed by human
  features/
    auth/
      slicing-ui/
        brief.md                # Context, Scope, Requirement, Clues, Keep in Mind
        plan.md                 # Generated by AI and reviewed by human
      integrate-be/
        brief.md                # Context, Scope, Requirement, Clues, Keep in Mind
        plan.md                 # Generated by AI and reviewed by human
  references/                   # Design references, screenshots, etc.
```

## Maestro Test Structure

The Maestro tests are organized following the entry point + runFlow pattern for better modularity and maintainability.

```
maestro/
├── all-tests.yaml                   # Master test orchestrator (entry point)
├── common/                          # Reusable flows shared between platforms
│   ├── auth-setup.yaml             # Authentication setup flow
│   └── setup-home.yaml             # Home screen setup flow
├── mobile/
│   └── flows/                      # Mobile-specific test flows
│       ├── auth-flow-mobile.yaml   # Mobile authentication tests
│       └── home-flow-mobile.yaml   # Mobile home screen tests
└── web/
    └── flows/                      # Web-specific test flows
        ├── auth-flow-web.yaml      # Web authentication tests
        └── home-flow-web.yaml      # Web home screen tests
```

**Key Principles:**
- `all-tests.yaml` is the entry point that orchestrates all test flows
- `common/` contains reusable flows shared between mobile and web
- `mobile/flows/` and `web/flows/` contain platform-specific test flows
- Each flow file uses `runFlow` to reference other flows
- Path references use relative paths (e.g., `../../common/auth-setup.yaml`)

**Running Tests:**
```bash
maestro test maestro/all-tests.yaml              # Run all tests
maestro test maestro/mobile/flows/               # Run all mobile tests
maestro test maestro/web/flows/                  # Run all web tests
maestro test maestro/common/auth-setup.yaml      # Run specific flow
```

## Commands

- `flutter run` — Run app
- `flutter test` — Run tests
- `flutter analyze` — Lint check
- `flutter build apk` — Build Android
- `flutter build ios` — Build iOS

## Notes

- Widgets under `features/*/presentation/widgets` are split into `mobile`, `web`, and `shared` folders; import the appropriate one in screens based on platform needs.

