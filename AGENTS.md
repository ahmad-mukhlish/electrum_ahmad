# Electrum Ahmad

Flutter mobile application.

## Tech Stack

- Flutter 3.x
- Dart SDK ^3.9.2
- State management: Riverpod (2 skills available)
- Routing: go_router
- Primary datasource: Firebase Auth and Firestore

## Why Riverpod

- Pairs cleanly with `go_router`; avoids routing conflicts seen with GetX.
- Less boilerplate and ceremony than Bloc while staying explicit and testable.
- Keeps dependency injection light and composable as features grow.

## Why Firebase Auth and Firestore

- Chosen to focus on app architecture, UX, and state management without owning backend buildout.
- Data access is funneled through the data layer so another backend can be swapped later without touching other layers.

## AI-assisted workflow and per-feature docs

- Each feature/task is documented in the `documentations/` folder (separate from code) with:
    - `brief.md` → manual brief containing:
        - Context
        - Scope
        - Requirements
        - Clues
        - Keep in mind
    - `plan.md` → AI-assisted implementation plan
      (generated with Claude / other tools and then curated).
- Current auth tasks documented under `documentations/features/docs/`:
    - `slicing-ui/brief.md` and `slicing-ui/plan.md`
    - `integrate-be/brief.md` and `integrate-be/plan.md`
- Repeat this pattern for every big task: add a subfolder under `documentations/features/docs/` or `documentations/core/` with `brief.md` and `plan.md` before implementation.


## Project Structure (following clean architecture with MVVM pattern)

```
lib/
  core/
    routing/                    # GoRouter configuration
    services/                   # Firebase Auth, Firestore, Local DB
    utils/                      # Helpers, Design tokens
    widgets/                    # Shared widgets
  features/
    auth/
      data/
        dtos/                   # JSON annotated dtos from datasources
        repositories/           # Implementation of domain repositories
        datasources/            # Data providers (Wrapper to API services / Local services)
      domain/
        entities/               # Business Entity (Model)
        repositories/           # Repository interfaces (contracts)
      presentation/
        viewmodel/
          notifiers/            # Notifiers (View model)
          states/               # Freezed UI states
        screens/                # Screen (View)
        widgets/
          mobile/               # Widgets tailored for mobile
          web/                  # Widgets tailored for web
          shared/               # Widgets shared between mobile and web
  main.dart                     # App entry point

documentations/                 # AI-assisted docs (separate from code)
  core/
    routing/
      brief.md                  # Context, Scope, Requirement, Clues, Keep in Mind
      plan.md                   # Generated by AI and reviewed by human
  features/
    docs/
      slicing-ui/
        brief.md                # Context, Scope, Requirement, Clues, Keep in Mind
        plan.md                 # Generated by AI and reviewed by human
      integrate-be/
        brief.md                # Context, Scope, Requirement, Clues, Keep in Mind
        plan.md                 # Generated by AI and reviewed by human
  references/                   # Design references, screenshots, etc.
```


## Commands

```bash
flutter run          # Run app
flutter test         # Run tests
flutter analyze      # Lint check
flutter build apk    # Build Android
flutter build ios    # Build iOS
```

## Conventions

- Skills stored in `.claude/skills`; use both available skills when applicable
- Firebase Auth + Firestore are used as the primary backend; keep access funneled through the data layer so other backends can be swapped in later if needed.
- AI-assisted development implementation: every big task keeps `documentations/<area>/<task>/brief.md` and `documentations/<area>/<task>/plan.md` (separate from code) so humans and AI share intent, maintain context across sessions, and minimize token usage.
- Design tokens (colors): use theme colors from `main.dart` via `Theme.of(context).colorScheme`, no hard codes
- use DRY and YAGNI principle
- avoid writing testing strategy at plan.md unless explicit mention at brief.md
- avoid writing code / implementation at plan.md
- Using `HookConsumerWidget` instead of `ConsumerStatefulWidget` for less boilerplate
- When more than 2 lines, create a named function instead of nameless function / lambda
- **Pass only what you need**: Extract minimal data before passing to methods (e.g., pass `String` instead of `TextEditingController`, pass `ColorScheme` instead of `BuildContext`)
- **Omit unused parameters**: Use single underscore `_` for unused callback parameters (e.g., `(_, next)` instead of `(previous, next)` if previous is unused)
- always use fat arrow => for functions whenever possible especially one line function
- **Delegate build_runner and flutter analyze to user**: To reduce token usage, avoid running `dart run build_runner build` and `flutter analyze` unless explicitly requested. Instead, remind the user to run these commands manually after code changes that require code generation or when checking for lint issues

### Error Handling in Data Layer

**All methods in datasources and repositories must use try-catch blocks with rethrow** to ensure proper error propagation through the data layer. This allows errors to bubble up to the presentation layer where they can be properly handled and displayed to users.

**Pattern:**
```dart
Future<UserDto> signInWithEmailAndPassword(
  String email,
  String password,
) async {
  try {
    final userCredential = await _firebaseAuth.signInWithEmailAndPassword(
      email: email,
      password: password,
    );

    return _userDtoFromFirebase(userCredential.user!);
  } catch (e) {
    rethrow;
  }
}
```

**Why this is important:**
- Ensures consistent error flow throughout the application
- Allows presentation layer to handle errors appropriately (show error messages, log errors, etc.)
- Makes debugging easier by preserving the original stack trace
- Maintains separation of concerns: data layer focuses on data operations, presentation layer handles user-facing error messages

**Apply this to:**
- All public methods in datasource classes
- All public methods in repository implementation classes
- Both async (Future) and sync methods that can throw errors

### Freezed Models (v3.0.0+)

**Important**: Freezed version 3.0.0 and above requires `sealed` or `abstract` modifier for classes using factory constructors. This is stated in the [V3 Migration Guide](https://pub.dev/packages/freezed#migration-guide).

**Correct Pattern:**
```dart
@freezed
abstract class User with _$User {
  const User._();

  const factory User({
    required String uid,
    required String email,
    String? displayName,
    String? photoUrl,
  }) = _User;
}
```

**Why this is needed:**
- Without `abstract` or `sealed`, Dart analyzer will show "Missing concrete implementations" errors
- The private constructor `const User._()` allows adding custom methods to Freezed classes
- After adding the modifier, run: `dart run build_runner build --delete-conflicting-outputs`

**Common patterns:**
- Use `abstract` for classes that may be extended
- Use `sealed` for closed type hierarchies (union types)
- Always include the private constructor if you need custom methods or extensions

### UI Widget Organization

- **Separate widgets by their role using builder methods**
- Extract UI components into descriptive methods for better readability and maintainability

Example structure:
```dart
class MyWidget extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        _buildHeader(),
        _buildContent(),
        _buildActionButtons(),
      ],
    );
  }

  Widget _buildHeader() {
    return Text('Header');
  }

  Widget _buildContent() {
    return Container(...);
  }

  Widget _buildActionButtons() {
    return Row(
      children: [
        _buildPrimaryButton(),
        _buildSecondaryButton(),
      ],
    );
  }

  Widget _buildPrimaryButton() {
    return FilledButton(...);
  }

  Widget _buildSecondaryButton() {
    return TextButton(...);
  }
}
```

**Benefits:**
- Cleaner code structure
- Easier to navigate and understand
- Simpler to modify individual sections
- Better code reusability within the widget